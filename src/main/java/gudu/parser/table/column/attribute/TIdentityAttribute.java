package gudu.parser.table.column.attribute;


import gudu.parser.TParseTree;

/**
 * Class that encapsulates identity column attribute.<br>
 * Identity columns are used mainly to ensure row uniqueness by taking a system-generated unique value.<br>
 * Example:
 * <code>
 * <p>
 * col1 INTEGER GENERATED BY DEFAULT AS IDENTITY <br>
 * (START WITH 1 <br>
 * INCREMENT BY 20 <br>
 * MAXVALUE 1000 <br>
 * ) <br>
 * <code/>
 */

public class TIdentityAttribute extends TColumnAttribute {
  private final boolean isAlwaysTokenPresent;
  private final TParseTree identityExpression;

  public TIdentityAttribute(boolean isAlwaysTokenPresent, TParseTree identityExpression) {
    this.isAlwaysTokenPresent = isAlwaysTokenPresent;
    this.identityExpression = identityExpression;
  }

  @Override
  public void unparse(StringBuilder writer) {
    writer.append("GENERATED ");
    if (isAlwaysTokenPresent) {
      writer.append("ALWAYS ");
    } else {
      writer.append("BY DEFAULT ");
    }
    writer.append("AS IDENTITY ");
    if (identityExpression != null) {
      identityExpression.unparse(writer);
    } else {
      writer.append("\n");
    }
  }

  public static class IdentityExpression extends TParseTree {
    private final TParseTree startsWith;
    private final TParseTree incrementBy;
    private final TParseTree minValue;
    private final boolean isNoMinValueTokenPresent;
    private final TParseTree maxValue;
    private final boolean isNoMaxValueTokenPresent;
    private final TParseTree cycle;

    public IdentityExpression(TParseTree startsWith, TParseTree incrementBy, TParseTree minValue,
                              boolean isNoMinValueTokenPresent, TParseTree maxValue,
                              boolean isNoMaxValueTokenPresent, TParseTree cycle) {
      this.startsWith = startsWith;
      this.incrementBy = incrementBy;
      this.minValue = minValue;
      this.isNoMinValueTokenPresent = isNoMinValueTokenPresent;
      this.maxValue = maxValue;
      this.isNoMaxValueTokenPresent = isNoMaxValueTokenPresent;
      this.cycle = cycle;
    }

    @Override
    public void unparse(StringBuilder writer) {
      writer.append("(");
      writer.append("START WITH ");
      startsWith.unparse(writer);
      writer.append("\n");
      writer.append("INCREMENT BY ");
      incrementBy.unparse(writer);
      writer.append("\n");
      if (isNoMinValueTokenPresent) {
        writer.append("NO MINVALUE");
      } else {
        writer.append("MINVALUE ");
        minValue.unparse(writer);
      }
      writer.append("\n");
      if (isNoMaxValueTokenPresent) {
        writer.append("NO MAXVALUE");
      } else {
        writer.append("MAXVALUE ");
        maxValue.unparse(writer);
      }
      writer.append("\n");
      cycle.unparse(writer);
      writer.append("\n");
      writer.append(")");
    }
  }
}
